[{"content":"介绍 Barrier是一款开源的多平台的鼠标键盘共享软件，可以在多台设备间共享鼠标和键盘，支持Windows、Linux、MacOS等多种操作系统(不同平台(例如一台Windows,一台Linux)的设备也可以共享一套鼠标键盘)。\n安装 Windows Winodws下安装很简单，直接下载这个安装包安装即可。\nLinux 各大发行版一般都有对应的包，例如Ubuntu可以直接使用apt安装：\nsudo apt install barrier 使用说明 这个软件有两种模式，一种是服务端模式，一种是客户端模式。使用的时候需要一台充当服务端，其他的设备充当客户端, 启动服务端之后, 客户端只需要脸上服务端的IP地址即可, 非常简单。\n使用过程中需要注意的点：\n  最好去掉SSL选项\n  asfdasdfasdf\n   ","permalink":"https://mkx000.github.io/posts/%E4%BD%BF%E7%94%A8barrier%E5%9C%A8%E5%A4%9A%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%97%B4%E5%85%B1%E4%BA%AB%E9%BC%A0%E6%A0%87%E5%92%8C%E9%94%AE%E7%9B%98/","summary":"介绍 Barrier是一款开源的多平台的鼠标键盘共享软件，可以在多台设备间共享鼠标和键盘，支持Windows、Linux、MacOS等多种操作系统(不同平台(例如一台Windows,一台Linux)的设备也可以共享一套鼠标键盘)。\n安装 Windows Winodws下安装很简单，直接下载这个安装包安装即可。\nLinux 各大发行版一般都有对应的包，例如Ubuntu可以直接使用apt安装：\nsudo apt install barrier 使用说明 这个软件有两种模式，一种是服务端模式，一种是客户端模式。使用的时候需要一台充当服务端，其他的设备充当客户端, 启动服务端之后, 客户端只需要脸上服务端的IP地址即可, 非常简单。\n使用过程中需要注意的点：\n  最好去掉SSL选项\n  asfdasdfasdf\n   ","title":"使用barrier在多台设备间共享鼠标和键盘"},{"content":"函数 The execution of a function introduces a new symbol table used for the local variables of the function. More precisely, all variable assignments in a function store the value in the local symbol table; whereas variable references first look in the local symbol table, then in the local symbol tables of enclosing functions, then in the global symbol table, and finally in the table of built-in names. Thus, global variables and variables of enclosing functions cannot be directly assigned a value within a function (unless, for global variables, named in a global statement, or, for variables of enclosing functions, named in a nonlocal statement), although they may be referenced.\nThe actual parameters (arguments) to a function call are introduced in the local symbol table of the called function when it is called; thus, arguments are passed using call by value (where the value is always an object reference, not the value of the object. Actually, call by object reference would be a better description, since if a mutable object is passed, the caller will see any changes the callee makes to it (items inserted into a list).). When a function calls another function, or calls itself recursively, a new local symbol table is created for that call.\nA function definition associates the function name with the function object in the current symbol table. The interpreter recognizes the object pointed to by that name as a user-defined function. Other names can also point to that same function object and can also be used to access the function:\n\u0026gt;\u0026gt;\u0026gt; def fib(): ... pass \u0026gt;\u0026gt;\u0026gt;fib \u0026lt;function fib at 10042ed0\u0026gt; \u0026gt;\u0026gt;\u0026gt;f = fib \u0026gt;\u0026gt;\u0026gt;f(100) 0 1 1 2 3 5 8 13 21 34 55 89 Coming from other languages, you might object that fib is not a function but a procedure since it doesn’t return a value. In fact, even functions without a return statement do return a value, albeit a rather boring one. This value is called None (it’s a built-in name). Writing the value None is normally suppressed by the interpreter if it would be the only value written. You can see it if you really want to using print():\n\u0026gt;\u0026gt;\u0026gt;fib(0) \u0026gt;\u0026gt;\u0026gt;print(fib(0)) None Default Argument Values The default values are evaluated(only once) at the point of function definition in the defining scope, so that\ni = 5 def f(arg=i): print(arg) i = 6 f() will print 5. 下面的代码片段会产生什么结果？\ndef f(a, L=[]): L.append(a) return L print(f(1)) print(f(2)) print(f(3)) ","permalink":"https://mkx000.github.io/posts/python%E6%98%AF%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E5%8F%98%E9%87%8F%E5%B9%B6%E5%AF%B9%E5%85%B6%E8%B5%8B%E5%80%BC%E7%9A%84/","summary":"函数 The execution of a function introduces a new symbol table used for the local variables of the function. More precisely, all variable assignments in a function store the value in the local symbol table; whereas variable references first look in the local symbol table, then in the local symbol tables of enclosing functions, then in the global symbol table, and finally in the table of built-in names. Thus, global variables and variables of enclosing functions cannot be directly assigned a value within a function (unless, for global variables, named in a global statement, or, for variables of enclosing functions, named in a nonlocal statement), although they may be referenced.","title":"python是如何查找标识符并对其赋值的"},{"content":"Overivew python is a dynamic typing language\u0026hellip;\ntips ","permalink":"https://mkx000.github.io/posts/intro-to-python/","summary":"Overivew python is a dynamic typing language\u0026hellip;\ntips ","title":"Intro to Python"},{"content":"","permalink":"https://mkx000.github.io/posts/langchain-summmay/","summary":"关于langchain的一些总结和思考, 各类资源汇总","title":"Langchain"},{"content":"Overview 文章出处在这里\nLLM powered autonomous agents: planning + memeoy + tool use\n1. planning Chain of thought:\n想法 prior work A: 可以通过产生用自然语言表达的中间步骤使得LLM获得更好的推理能力, techniques for arithmetic reasoning can benefit from generating natural language rationales that lead to the final answer。\n缺点: 要想训练具有良好推理能力的大模型(或者fine-tune a pretrained model), 需要大量的高质量推理数据集, 成本太高, 远远超过简单的input-output pairs。\nprior work B: 大模型已经可以通过prompt工程获得出色的少样本学习能力, large language models offer the exciting prospect of in-context few-shot learning via prompting. That is, instead of finetuning a separate language model checkpoint for each new task, one can simply “prompt” the model with a few input–output exemplars demonstrating the task\n缺点: 使用传统的少样本学习方法，大模型在推理能力上的表现不佳。而且随着模型参数量的提升，推理能力没有明显的提升。\n本文的idea：结合A和B的优点，同时避免缺点, 通过少样本的prompt使大模型获得推理能力,具体来说: 给出一个prompt: \u0026lt;输入, 思维链(CoT, chain-of-thought), 输出\u0026gt;, 其中思维链(CoT)是一系列由自然语言表示的中间过程。 这个方法被称为思维链提示工程(CoT, chain-of-thought prompting)。\n思维链提示过程 (chain of thought prompting) CoT prompting 对于语言模型获得推理能力有重要意义，主要是它有若干特性:\na. 步骤分解，原则上，这意味着每一步都可以使用额外的计算过程。\nb. 可解释性强，每一步都可以用自然语言表示，容易debug (但是，fully characterizing a model’s computations that support an answer remains an open question)。\nc. 应用范围广，CoT可以应用于math word problems, common sense reasoning, symbolic manipulation，甚至是所有能用自然语言表述的问题。\nd. 使用简单，只需要一个prompt，而不是一个大的训练集。\n实验过程 略去\u0026hellip;\n结果 通过构建thought-action-observation-thought\u0026hellip; 这样的思维链，可以使得模型在推理能力上有明显的提升。具体结果如下图：\nthoughts:\na. CoT的效果会随着模型参数量的增加而越来越明显，对于小模型效果可能为负\nb. CoT更加适应复杂问题，对于简单问题，CoT的效果可能不如直接使用standard prompt\nc. 在GPT-3 175B和PaLM 540B上实验可以在三个数据集上达到SoTA，在另外两个数据集上效果与SoTA相当(相差2%以内)。\nTree of Thoughts\n想法1 a.\nb.\nReAct,e.g. reason-action:\n","permalink":"https://mkx000.github.io/posts/%E7%AC%94%E8%AE%B0-llm-powered-agents/","summary":"Overview 文章出处在这里\nLLM powered autonomous agents: planning + memeoy + tool use\n1. planning Chain of thought:\n想法 prior work A: 可以通过产生用自然语言表达的中间步骤使得LLM获得更好的推理能力, techniques for arithmetic reasoning can benefit from generating natural language rationales that lead to the final answer。\n缺点: 要想训练具有良好推理能力的大模型(或者fine-tune a pretrained model), 需要大量的高质量推理数据集, 成本太高, 远远超过简单的input-output pairs。\nprior work B: 大模型已经可以通过prompt工程获得出色的少样本学习能力, large language models offer the exciting prospect of in-context few-shot learning via prompting. That is, instead of finetuning a separate language model checkpoint for each new task, one can simply “prompt” the model with a few input–output exemplars demonstrating the task","title":"LLM Powered Autonomous Agents"},{"content":"测试环境 WSL2 + VSCode\n安装必要的软件包 # 安装hugo sudo apt install hugo 创建网站 # 创建网站, 替换your-website-name为自己想要的名字 hugo new site your-website-name -f yml 配置网站 You can learn more and see more configuration settings that work with the PaperMod theme in the documentation.\n本地运行网站 # 进入网站目录 cd your-website-name # 下载主题 git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod --depth=1 # 运行网站 hugo server -D ","permalink":"https://mkx000.github.io/posts/github-pages-+-hugo-+-papermod%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","summary":"This post provides an overview of Hugo (PaperMod theme) and details the steps I took in setting up this website.","title":"Github Pages + Hugo + PaperMod搭建个人博客"}]